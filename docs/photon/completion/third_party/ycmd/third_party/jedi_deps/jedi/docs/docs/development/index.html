
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Jedi Development &#8212; PHOTON platform&lt;br/&gt;•&lt;br/&gt;.vim  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/photonsphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/graphviz.css" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../../../../../../_static/jquery.js"></script>
    <script src="../../../../../../../../../../_static/underscore.js"></script>
    <script src="../../../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../../../../../../../_static/doctools.js"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js"></script>
    <link rel="canonical" href="https://photon-platform.github.io/vim/photon/completion/third_party/ycmd/third_party/jedi_deps/jedi/docs/docs/development.html" />
    <link rel="index" title="Index" href="../../../../../../../../../../genindex/" />
    <link rel="search" title="Search" href="../../../../../../../../../../search/" /> 
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />
 
<link
  rel="alternate"
  type="application/atom+xml"
  href="../../../../../../../../../../log/atom.xml"
  title="PHOTON platform • .vim"
/>
 
<style type="text/css">
  ul.ablog-archive {
    list-style: none;
    overflow: auto;
    margin-left: 0px;
  }
  ul.ablog-archive li {
    float: left;
    margin-right: 5px;
    font-size: 80%;
  }
  ul.postlist a {
    font-style: italic;
  }
  ul.postlist-style-disc {
    list-style-type: disc;
  }
  ul.postlist-style-none {
    list-style-type: none;
  }
  ul.postlist-style-circle {
    list-style-type: circle;
  }
</style>

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
             <section id="jedi-development">
<h1>Jedi Development<a class="headerlink" href="#jedi-development" title="Permalink to this heading">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This documentation is for Jedi developers who want to improve Jedi
itself, but have no idea how Jedi works. If you want to use Jedi for
your IDE, look at the <a class="reference external" href="api.html">plugin api</a>.
It is also important to note that it’s a pretty old version and some things
might not apply anymore.</p>
</div>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>This page tries to address the fundamental demand for documentation of the
Jedi internals. Understanding a dynamic language is a complex task. Especially
because type inference in Python can be a very recursive task. Therefore Jedi
couldn’t get rid of complexity. I know that <strong>simple is better than complex</strong>,
but unfortunately it sometimes requires complex solutions to understand complex
systems.</p>
<p>In six chapters I’m trying to describe the internals of Jedi:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#core"><span class="std std-ref">The Jedi Core</span></a></p></li>
<li><p><a class="reference internal" href="#core-extensions"><span class="std std-ref">Core Extensions</span></a></p></li>
<li><p><a class="reference internal" href="#imports-modules"><span class="std std-ref">Imports &amp; Modules</span></a></p></li>
<li><p><a class="reference internal" href="#stubs"><span class="std std-ref">Stubs &amp; Annotations</span></a></p></li>
<li><p><a class="reference internal" href="#caching-recursions"><span class="std std-ref">Caching &amp; Recursions</span></a></p></li>
<li><p><a class="reference internal" href="#dev-helpers"><span class="std std-ref">Helper modules</span></a></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Testing is not documented here, you’ll find that
<a class="reference external" href="testing.html">right here</a>.</p>
</div>
</section>
<section id="the-jedi-core">
<span id="core"></span><h2>The Jedi Core<a class="headerlink" href="#the-jedi-core" title="Permalink to this heading">¶</a></h2>
<p>The core of Jedi consists of three parts:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#parser"><span class="std std-ref">Parser</span></a></p></li>
<li><p><a class="reference internal" href="#inference"><span class="std std-ref">Python type inference</span></a></p></li>
<li><p><a class="reference internal" href="#dev-api"><span class="std std-ref">API</span></a></p></li>
</ul>
<p>Most people are probably interested in <a class="reference internal" href="#inference"><span class="std std-ref">type inference</span></a>,
because that’s where all the magic happens. I need to introduce the <a class="reference internal" href="#parser"><span class="std std-ref">parser</span></a> first, because <a class="reference internal" href="#module-jedi.inference" title="jedi.inference"><code class="xref py py-mod docutils literal notranslate"><span class="pre">jedi.inference</span></code></a> uses it extensively.</p>
<section id="parser">
<span id="id1"></span><h3>Parser<a class="headerlink" href="#parser" title="Permalink to this heading">¶</a></h3>
<p>Jedi used to have its internal parser, however this is now a separate project
and is called <a class="reference external" href="http://parso.readthedocs.io">parso</a>.</p>
<p>The parser creates a syntax tree that Jedi analyses and tries to understand.
The grammar that this parser uses is very similar to the official Python
<a class="reference external" href="https://docs.python.org/3/reference/grammar.html">grammar files</a>.</p>
</section>
<section id="module-jedi.inference">
<span id="type-inference-of-python-code-inference-init-py"></span><span id="inference"></span><h3>Type inference of python code (inference/__init__.py)<a class="headerlink" href="#module-jedi.inference" title="Permalink to this heading">¶</a></h3>
<p>Type inference of Python code in Jedi is based on three assumptions:</p>
<ul class="simple">
<li><p>The code uses as least side effects as possible. Jedi understands certain
list/tuple/set modifications, but there’s no guarantee that Jedi detects
everything (list.append in different modules for example).</p></li>
<li><p>No magic is being used:</p>
<ul>
<li><p>metaclasses</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">setattr()</span></code> / <code class="docutils literal notranslate"><span class="pre">__import__()</span></code></p></li>
<li><p>writing to <code class="docutils literal notranslate"><span class="pre">globals()</span></code>, <code class="docutils literal notranslate"><span class="pre">locals()</span></code>, <code class="docutils literal notranslate"><span class="pre">object.__dict__</span></code></p></li>
</ul>
</li>
<li><p>The programmer is not a total dick, e.g. like <a class="reference external" href="https://github.com/davidhalter/jedi/issues/24">this</a> :-)</p></li>
</ul>
<p>The actual algorithm is based on a principle I call lazy type inference.  That
said, the typical entry point for static analysis is calling
<code class="docutils literal notranslate"><span class="pre">infer_expr_stmt</span></code>. There’s separate logic for autocompletion in the API, the
inference_state is all about inferring an expression.</p>
<p>TODO this paragraph is not what jedi does anymore, it’s similar, but not the
same.</p>
<p>Now you need to understand what follows after <code class="docutils literal notranslate"><span class="pre">infer_expr_stmt</span></code>. Let’s
make an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">toda</span><span class="c1"># &lt;-- cursor here</span>
</pre></div>
</div>
<p>First of all, this module doesn’t care about completion. It really just cares
about <code class="docutils literal notranslate"><span class="pre">datetime.date</span></code>. At the end of the procedure <code class="docutils literal notranslate"><span class="pre">infer_expr_stmt</span></code> will
return the <code class="docutils literal notranslate"><span class="pre">date</span></code> class.</p>
<p>To <em>visualize</em> this (simplified):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">InferenceState.infer_expr_stmt</span></code> doesn’t do much, because there’s no assignment.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Context.infer_node</span></code> cares for resolving the dotted path</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">InferenceState.find_types</span></code> searches for global definitions of datetime, which
it finds in the definition of an import, by scanning the syntax tree.</p></li>
<li><p>Using the import logic, the datetime module is found.</p></li>
<li><p>Now <code class="docutils literal notranslate"><span class="pre">find_types</span></code> is called again by <code class="docutils literal notranslate"><span class="pre">infer_node</span></code> to find <code class="docutils literal notranslate"><span class="pre">date</span></code>
inside the datetime module.</p></li>
</ul>
<p>Now what would happen if we wanted <code class="docutils literal notranslate"><span class="pre">datetime.date.foo.bar</span></code>? Two more
calls to <code class="docutils literal notranslate"><span class="pre">find_types</span></code>. However the second call would be ignored, because the
first one would return nothing (there’s no foo attribute in <code class="docutils literal notranslate"><span class="pre">date</span></code>).</p>
<p>What if the import would contain another <code class="docutils literal notranslate"><span class="pre">ExprStmt</span></code> like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">bar</span>
<span class="n">Date</span> <span class="o">=</span> <span class="n">bar</span><span class="o">.</span><span class="n">baz</span>
</pre></div>
</div>
<p>Well… You get it. Just another <code class="docutils literal notranslate"><span class="pre">infer_expr_stmt</span></code> recursion. It’s really
easy. Python can obviously get way more complicated then this. To understand
tuple assignments, list comprehensions and everything else, a lot more code had
to be written.</p>
<p>Jedi has been tested very well, so you can just start modifying code. It’s best
to write your own test first for your “new” feature. Don’t be scared of
breaking stuff. As long as the tests pass, you’re most likely to be fine.</p>
<p>I need to mention now that lazy type inference is really good because it
only <em>inferes</em> what needs to be <em>inferred</em>. All the statements and modules
that are not used are just being ignored.</p>
<section id="module-jedi.inference.base_value">
<span id="inference-values-inference-base-value-py"></span><h4>Inference Values (inference/base_value.py)<a class="headerlink" href="#module-jedi.inference.base_value" title="Permalink to this heading">¶</a></h4>
<p>Values are the “values” that Python would return. However Values are at the
same time also the “values” that a user is currently sitting in.</p>
<p>A ValueSet is typically used to specify the return of a function or any other
static analysis operation. In jedi there are always multiple returns and not
just one.</p>
</section>
<section id="module-jedi.inference.finder">
<span id="name-resolution-inference-finder-py"></span><span id="name-resolution"></span><h4>Name resolution (inference/finder.py)<a class="headerlink" href="#module-jedi.inference.finder" title="Permalink to this heading">¶</a></h4>
<p>Searching for names with given scope and name. This is very central in Jedi and
Python. The name resolution is quite complicated with descripter,
<code class="docutils literal notranslate"><span class="pre">__getattribute__</span></code>, <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code>, <code class="docutils literal notranslate"><span class="pre">global</span></code>, etc.</p>
<p>If you want to understand name resolution, please read the first few chapters
in <a class="reference external" href="http://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/">http://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/</a>.</p>
<section id="flow-checks">
<h5>Flow checks<a class="headerlink" href="#flow-checks" title="Permalink to this heading">¶</a></h5>
<p>Flow checks are not really mature. There’s only a check for <code class="docutils literal notranslate"><span class="pre">isinstance</span></code>.  It
would check whether a flow has the form of <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">isinstance(a,</span> <span class="pre">type_or_tuple)</span></code>.
Unfortunately every other thing is being ignored (e.g. a == ‘’ would be easy to
check for -&gt; a is a string). There’s big potential in these checks.</p>
</section>
</section>
</section>
<section id="api-api-init-py-and-api-classes-py">
<span id="dev-api"></span><h3>API (api/__init__.py and api/classes.py)<a class="headerlink" href="#api-api-init-py-and-api-classes-py" title="Permalink to this heading">¶</a></h3>
<p>The API has been designed to be as easy to use as possible. The API
documentation can be found <a class="reference external" href="api.html">here</a>. The API itself contains
little code that needs to be mentioned here. Generally I’m trying to be
conservative with the API.  I’d rather not add new API features if they are not
necessary, because it’s much harder to deprecate stuff than to add it later.</p>
</section>
</section>
<section id="core-extensions">
<span id="id2"></span><h2>Core Extensions<a class="headerlink" href="#core-extensions" title="Permalink to this heading">¶</a></h2>
<p>Core Extensions is a summary of the following topics:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#iterables"><span class="std std-ref">Iterables &amp; Dynamic Arrays</span></a></p></li>
<li><p><a class="reference internal" href="#dynamic-params"><span class="std std-ref">Dynamic Parameters</span></a></p></li>
<li><p><a class="reference internal" href="#docstrings"><span class="std std-ref">Docstrings</span></a></p></li>
<li><p><a class="reference internal" href="#refactoring"><span class="std std-ref">Refactoring</span></a></p></li>
</ul>
<p>These topics are very important to understand what Jedi additionally does, but
they could be removed from Jedi and Jedi would still work. But slower and
without some features.</p>
<section id="iterables-dynamic-arrays-inference-value-iterable-py">
<span id="iterables"></span><h3>Iterables &amp; Dynamic Arrays (inference/value/iterable.py)<a class="headerlink" href="#iterables-dynamic-arrays-inference-value-iterable-py" title="Permalink to this heading">¶</a></h3>
<p>To understand Python on a deeper level, Jedi needs to understand some of the
dynamic features of Python like lists that are filled after creation:</p>
<span class="target" id="module-jedi.inference.value.iterable"></span><p>Contains all classes and functions to deal with lists, dicts, generators and
iterators in general.</p>
</section>
<section id="module-jedi.inference.dynamic_params">
<span id="parameter-completion-inference-dynamic-params-py"></span><span id="dynamic-params"></span><h3>Parameter completion (inference/dynamic_params.py)<a class="headerlink" href="#module-jedi.inference.dynamic_params" title="Permalink to this heading">¶</a></h3>
<p>One of the really important features of Jedi is to have an option to
understand code like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">):</span>
    <span class="n">bar</span><span class="o">.</span> <span class="c1"># completion here</span>
<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>There’s no doubt wheter bar is an <code class="docutils literal notranslate"><span class="pre">int</span></code> or not, but if there’s also a call
like <code class="docutils literal notranslate"><span class="pre">foo('str')</span></code>, what would happen? Well, we’ll just show both. Because
that’s what a human would expect.</p>
<p>It works as follows:</p>
<ul class="simple">
<li><p>Jedi sees a param</p></li>
<li><p>search for function calls named <code class="docutils literal notranslate"><span class="pre">foo</span></code></p></li>
<li><p>execute these calls and check the input.</p></li>
</ul>
</section>
<section id="module-jedi.inference.docstrings">
<span id="docstrings-inference-docstrings-py"></span><span id="docstrings"></span><h3>Docstrings (inference/docstrings.py)<a class="headerlink" href="#module-jedi.inference.docstrings" title="Permalink to this heading">¶</a></h3>
<p>Docstrings are another source of information for functions and classes.
<a class="reference internal" href="#module-jedi.inference.dynamic_params" title="jedi.inference.dynamic_params"><code class="xref py py-mod docutils literal notranslate"><span class="pre">jedi.inference.dynamic_params</span></code></a> tries to find all executions of functions,
while the docstring parsing is much easier. There are three different types of
docstrings that Jedi understands:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://sphinx-doc.org/markup/desc.html#info-field-lists">Sphinx</a></p></li>
<li><p><a class="reference external" href="http://epydoc.sourceforge.net/manual-fields.html">Epydoc</a></p></li>
<li><p><a class="reference external" href="https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt">Numpydoc</a></p></li>
</ul>
<p>For example, the sphinx annotation <code class="docutils literal notranslate"><span class="pre">:type</span> <span class="pre">foo:</span> <span class="pre">str</span></code> clearly states that the
type of <code class="docutils literal notranslate"><span class="pre">foo</span></code> is <code class="docutils literal notranslate"><span class="pre">str</span></code>.</p>
<p>As an addition to parameter searching, this module also provides return
annotations.</p>
</section>
<section id="module-jedi.api.refactoring">
<span id="refactoring-api-refactoring-py"></span><span id="refactoring"></span><h3>Refactoring (api/refactoring.py)<a class="headerlink" href="#module-jedi.api.refactoring" title="Permalink to this heading">¶</a></h3>
</section>
</section>
<section id="imports-modules">
<span id="id3"></span><h2>Imports &amp; Modules<a class="headerlink" href="#imports-modules" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p><span class="xref std std-ref">Modules</span></p></li>
<li><p><a class="reference internal" href="#builtin"><span class="std std-ref">Builtin Modules</span></a></p></li>
<li><p><a class="reference internal" href="#imports"><span class="std std-ref">Imports</span></a></p></li>
</ul>
<section id="module-jedi.inference.compiled">
<span id="compiled-modules-inference-compiled-py"></span><span id="builtin"></span><h3>Compiled Modules (inference/compiled.py)<a class="headerlink" href="#module-jedi.inference.compiled" title="Permalink to this heading">¶</a></h3>
</section>
<section id="module-jedi.inference.imports">
<span id="imports-inference-imports-py"></span><span id="imports"></span><h3>Imports (inference/imports.py)<a class="headerlink" href="#module-jedi.inference.imports" title="Permalink to this heading">¶</a></h3>
<p><a class="reference internal" href="#module-jedi.inference.imports" title="jedi.inference.imports"><code class="xref py py-mod docutils literal notranslate"><span class="pre">jedi.inference.imports</span></code></a> is here to resolve import statements and return
the modules/classes/functions/whatever, which they stand for. However there’s
not any actual importing done. This module is about finding modules in the
filesystem. This can be quite tricky sometimes, because Python imports are not
always that simple.</p>
<p>This module also supports import autocompletion, which means to complete
statements like <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">datetim</span></code> (cursor at the end would return <code class="docutils literal notranslate"><span class="pre">datetime</span></code>).</p>
</section>
<section id="module-jedi.inference.gradual">
<span id="stubs-annotations-inference-gradual"></span><span id="stubs"></span><h3>Stubs &amp; Annotations (inference/gradual)<a class="headerlink" href="#module-jedi.inference.gradual" title="Permalink to this heading">¶</a></h3>
<p>It is unfortunately not well documented how stubs and annotations work in Jedi.
If somebody needs an introduction, please let me know.</p>
</section>
</section>
<section id="caching-recursions">
<span id="id4"></span><h2>Caching &amp; Recursions<a class="headerlink" href="#caching-recursions" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="#cache"><span class="std std-ref">Caching</span></a></p></li>
<li><p><a class="reference internal" href="#recursion"><span class="std std-ref">Recursions</span></a></p></li>
</ul>
<section id="module-jedi.cache">
<span id="caching-cache-py"></span><span id="cache"></span><h3>Caching (cache.py)<a class="headerlink" href="#module-jedi.cache" title="Permalink to this heading">¶</a></h3>
<p>This caching is very important for speed and memory optimizations. There’s
nothing really spectacular, just some decorators. The following cache types are
available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">time_cache</span></code> can be used to cache something for just a limited time span,
which can be useful if there’s user interaction and the user cannot react
faster than a certain time.</p></li>
</ul>
<p>This module is one of the reasons why Jedi is not thread-safe. As you can see
there are global variables, which are holding the cache information. Some of
these variables are being cleaned after every API usage.</p>
</section>
<section id="module-jedi.inference.recursion">
<span id="recursions-recursion-py"></span><span id="recursion"></span><h3>Recursions (recursion.py)<a class="headerlink" href="#module-jedi.inference.recursion" title="Permalink to this heading">¶</a></h3>
<p>Recursions are the recipe of Jedi to conquer Python code. However, someone
must stop recursions going mad. Some settings are here to make Jedi stop at
the right time. You can read more about them <a class="reference internal" href="#settings-recursion"><span class="std std-ref">here</span></a>.</p>
<p>Next to the internal <code class="docutils literal notranslate"><span class="pre">jedi.inference.cache</span></code> this module also makes Jedi not
thread-safe, because <code class="docutils literal notranslate"><span class="pre">execution_recursion_decorator</span></code> uses class variables to
count the function calls.</p>
<section id="settings">
<span id="settings-recursion"></span><h4>Settings<a class="headerlink" href="#settings" title="Permalink to this heading">¶</a></h4>
<p>Recursion settings are important if you don’t want extremely
recursive python code to go absolutely crazy.</p>
<p>The default values are based on experiments while completing the Jedi library
itself (inception!). But I don’t think there’s any other Python library that
uses recursion in a similarly extreme way. Completion should also be fast and
therefore the quality might not always be maximal.</p>
<dl class="py data">
<dt class="sig sig-object py" id="jedi.inference.recursion.recursion_limit">
<span class="sig-prename descclassname"><span class="pre">jedi.inference.recursion.</span></span><span class="sig-name descname"><span class="pre">recursion_limit</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">15</span></em><a class="headerlink" href="#jedi.inference.recursion.recursion_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrecursionlimit()</span></code>, just for Jedi.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="jedi.inference.recursion.total_function_execution_limit">
<span class="sig-prename descclassname"><span class="pre">jedi.inference.recursion.</span></span><span class="sig-name descname"><span class="pre">total_function_execution_limit</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">200</span></em><a class="headerlink" href="#jedi.inference.recursion.total_function_execution_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a hard limit of how many non-builtin functions can be executed.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="jedi.inference.recursion.per_function_execution_limit">
<span class="sig-prename descclassname"><span class="pre">jedi.inference.recursion.</span></span><span class="sig-name descname"><span class="pre">per_function_execution_limit</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">6</span></em><a class="headerlink" href="#jedi.inference.recursion.per_function_execution_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximal amount of times a specific function may be executed.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="jedi.inference.recursion.per_function_recursion_limit">
<span class="sig-prename descclassname"><span class="pre">jedi.inference.recursion.</span></span><span class="sig-name descname"><span class="pre">per_function_recursion_limit</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#jedi.inference.recursion.per_function_recursion_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>A function may not be executed more than this number of times recursively.</p>
</dd></dl>

</section>
</section>
</section>
<section id="helper-modules">
<span id="dev-helpers"></span><h2>Helper Modules<a class="headerlink" href="#helper-modules" title="Permalink to this heading">¶</a></h2>
<p>Most other modules are not really central to how Jedi works. They all contain
relevant code, but you if you understand the modules above, you pretty much
understand Jedi.</p>
</section>
</section>

<div class="section">
   
</div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../../../../../../../../">
    <img class="logo" src="../../../../../../../../../../_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">PHOTON platform<br/>•<br/>.vim</h1>
    
  </a>
</p>





<iframe src="https://ghbtns.com/github-btn.html?user=photon-platform&type=follow&count=true&size=large" frameborder="0" scrolling="0" width="230" height="30" title="GitHub"></iframe>


<p>
<iframe src="https://ghbtns.com/github-btn.html?user=photon-platform&repo=vim&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>




<!-- <h3>Navigation</h3> -->


<h3>
  <a href="../../../../../../../../../../log/">LOG recent</a>
</h3>
<ul>
   
  <li>
    <a href="../../../../../../../../../../log/22.348-113439/"
      >22.348 - Welcome to the .vim project</a
    >
  </li>
  
</ul>

<h3>
  <a href="../../../../../../../../../../log/category/">Categories</a>
</h3>
<ul>
   
  <li>
    <a href="../../../../../../../../../../log/category/status/">STATUS (1)</a>
  </li>
   
</ul>

<h3>
  <a href="../../../../../../../../../../log/archive/">Archives</a>
</h3>
<ul>
   
  <li>
    <a href="../../../../../../../../../../log/2022/">2022 (1)</a>
  </li>
   
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search/" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, PHOTON platform.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/photon-platform/photon-sphinx-theme">PHOTON Sphinx 0.0.1</a>
      
      |
      <a href="../../../../../../../../../../_sources/photon/completion/third_party/ycmd/third_party/jedi_deps/jedi/docs/docs/development.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>